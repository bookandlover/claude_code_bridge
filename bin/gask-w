#!/usr/bin/env python3
"""
gask-w - Send message to Gemini and wait for reply (pure sync mode)
Designed to be run with Claude Code's run_in_background=true
"""
from __future__ import annotations
import os
import sys
from pathlib import Path

script_dir = Path(__file__).resolve().parent
lib_dir = script_dir.parent / "lib"
sys.path.insert(0, str(lib_dir))


def main(argv: list[str]) -> int:
    if len(argv) <= 1:
        print("Usage: gask-w <message>", file=sys.stderr)
        return 1

    message = " ".join(argv[1:]).strip()
    if not message:
        print("‚ùå Message cannot be empty", file=sys.stderr)
        return 1

    if sys.platform == "win32":
        from compat import setup_windows_encoding
        setup_windows_encoding()

    from gemini_comm import GeminiCommunicator
    from i18n import t

    try:
        comm = GeminiCommunicator(lazy_init=True)

        # Check session health
        healthy, status = comm._check_session_health_impl(probe_terminal=False)
        if not healthy:
            print(f"‚ùå Session error: {status}", file=sys.stderr)
            return 1

        # Send message
        print(f"üîî {t('sending_to', provider='Gemini')}", flush=True)
        state = comm.log_reader.capture_state()
        comm._send_via_terminal(message)

        # Pure sync wait (default 1 hour, configurable via CCB_SYNC_TIMEOUT)
        sync_timeout = float(os.environ.get("CCB_SYNC_TIMEOUT", "3600.0"))
        message_reply, _ = comm.log_reader.wait_for_message(state, sync_timeout)

        # Save to cache
        cache_dir = Path.home() / ".cache" / "ccb"
        cache_dir.mkdir(parents=True, exist_ok=True)
        reply_file = cache_dir / "gemini_last_reply.txt"

        if message_reply:
            print(f"ü§ñ {t('reply_from', provider='Gemini')}")
            print(message_reply)
            reply_file.write_text(message_reply, encoding="utf-8")
        else:
            print(f"‚è∞ Timeout after {int(sync_timeout)}s")
        return 0

    except Exception as exc:
        print(f"‚ùå {exc}", file=sys.stderr)
        return 1


if __name__ == "__main__":
    raise SystemExit(main(sys.argv))
