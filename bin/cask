#!/usr/bin/env python3
"""
cask - Send message to Codex and wait for reply (sync).

Designed to be used with Claude Code's run_in_background=true.
If --output is provided, the reply is written atomically to that file and stdout stays empty.
"""
from __future__ import annotations
import json
import os
import re
import subprocess
import sys
import time
import uuid
from pathlib import Path
from typing import Optional, Tuple

script_dir = Path(__file__).resolve().parent
lib_dir = script_dir.parent / "lib"
sys.path.insert(0, str(lib_dir))
from compat import setup_windows_encoding
setup_windows_encoding()

COMPLETION_MARKER_BASE = (os.environ.get("CCB_EXECUTION_COMPLETE_MARKER") or "EXECUTION_COMPLETE").strip() or "EXECUTION_COMPLETE"

SUPERVISOR_PROMPT = """## Executor Mode: codex+opencode
You are the SUPERVISOR, NOT the executor.
- Do NOT directly edit repo files yourself.
- Break down tasks into clear instructions for OpenCode.
- Use oask to delegate execution to OpenCode.
- Review OpenCode results and iterate if needed.

"""


def _get_executor_from_roles() -> Optional[str]:
    """Read executor from roles config (priority: session > project > global)."""
    candidates = [
        Path(".autoflow/roles.session.json"),
        Path(".autoflow/roles.json"),
        Path.home() / ".config" / "cca" / "roles.json",
    ]
    for cfg_path in candidates:
        if cfg_path.exists():
            try:
                data = json.loads(cfg_path.read_text(encoding="utf-8"))
                executor = data.get("executor")
                if executor:
                    return executor
            except Exception:
                pass
    return None


def _build_markers(request_id: str) -> tuple[str, str]:
    start_marker = f"{COMPLETION_MARKER_BASE}:BEGIN:{request_id}"
    end_marker = f"{COMPLETION_MARKER_BASE}:END:{request_id}"
    return start_marker, end_marker


def _marker_regex(marker: str) -> re.Pattern:
    escaped = [re.escape(ch) for ch in marker]
    pattern = r"\s*".join(escaped)
    return re.compile(pattern, re.DOTALL)


def _marker_in_text(text: str, marker: str) -> bool:
    return bool(_marker_regex(marker).search(text))


def _strip_markers(text: str, start_marker: str, end_marker: str) -> str:
    """Remove marker lines (start/end) from the reply."""
    for marker in (start_marker, end_marker):
        text = _marker_regex(marker).sub("", text)
    return text.strip()


def _wait_for_complete_reply(log_reader, state: dict, timeout: float, quiet: bool,
                             start_marker: str, end_marker: str):
    """Wait until reply ends with end_marker or timeout."""
    from cli_output import EXIT_NO_REPLY, EXIT_OK

    deadline = time.time() + timeout
    chunks = []
    collecting = False

    def _handle_reply(reply: str) -> Optional[str]:
        nonlocal collecting, chunks
        has_start = _marker_in_text(reply, start_marker)
        has_end = _marker_in_text(reply, end_marker)
        if not collecting:
            if has_start or has_end:
                collecting = True
                chunks.append(reply)
            else:
                return None
        else:
            chunks.append(reply)
        if has_end:
            combined = "\n".join(chunks)
            return _strip_markers(combined, start_marker, end_marker)
        return None

    # Pre-check: try to read existing messages (may have arrived before we started)
    try:
        existing_reply, state = log_reader.wait_for_message(state, timeout=0.1)
        if existing_reply:
            result = _handle_reply(existing_reply)
            if result is not None:
                return result, EXIT_OK
    except Exception:
        pass

    while True:
        remaining = deadline - time.time()
        if remaining <= 0:
            break
        reply, state = log_reader.wait_for_message(state, remaining)
        if reply is None:
            continue
        result = _handle_reply(reply)
        if result is not None:
            return result, EXIT_OK

    if chunks and collecting:
        if not quiet:
            print("[WARN] cask_marker_missing: marker not detected for this request, returning partial reply", file=sys.stderr)
        combined = "\n".join(chunks)
        return _strip_markers(combined, start_marker, end_marker), EXIT_NO_REPLY
    return None, EXIT_NO_REPLY


def _with_completion_marker_request(message: str, start_marker: str, end_marker: str) -> str:
    if not message:
        return message
    if start_marker in message or end_marker in message:
        return message
    return (
        f"{message}\n\n"
        "IMPORTANT:\n"
        "- You MUST reply with a final response (do not stay silent).\n"
        f"- Begin your reply with this exact line (verbatim):\n{start_marker}\n"
        f"- End your reply with this exact line (verbatim):\n{end_marker}\n"
        "- Reply in a single message if possible.\n"
    )

def _usage() -> None:
    print("Usage: cask [--timeout SECONDS] [--output FILE] <message>", file=sys.stderr)


def _check_background_mode() -> bool:
    """Return True when stdout looks like Claude Code run_in_background output capture."""
    if os.environ.get("CLAUDECODE") != "1":
        return True
    if os.environ.get("CCB_ALLOW_FOREGROUND") in ("1", "true", "yes"):
        return True
    # Claude Code's run_in_background captures stdout via file, socket, or FIFO/pipe.
    try:
        import stat
        mode = os.fstat(sys.stdout.fileno()).st_mode
        return stat.S_ISREG(mode) or stat.S_ISSOCK(mode) or stat.S_ISFIFO(mode)
    except Exception:
        return False


def _popen_detached(argv: list[str]) -> None:
    kwargs = {
        "stdin": subprocess.DEVNULL,
        "stdout": subprocess.DEVNULL,
        "stderr": subprocess.DEVNULL,
        "close_fds": True,
    }
    if os.name == "nt":
        kwargs["creationflags"] = getattr(subprocess, "DETACHED_PROCESS", 0) | getattr(subprocess, "CREATE_NEW_PROCESS_GROUP", 0)
    else:
        kwargs["start_new_session"] = True
    subprocess.Popen(argv, **kwargs)


def _parse_args(argv: list[str]) -> Tuple[Optional[Path], float, str, bool]:
    output: Optional[Path] = None
    timeout: Optional[float] = None
    quiet = False
    parts: list[str] = []

    it = iter(argv[1:])
    for token in it:
        if token in ("-h", "--help"):
            _usage()
            raise SystemExit(0)
        if token in ("-q", "--quiet"):
            quiet = True
            continue
        if token in ("-o", "--output"):
            try:
                output = Path(next(it)).expanduser()
            except StopIteration:
                raise ValueError("--output requires a file path")
            continue
        if token in ("-t", "--timeout"):
            try:
                timeout = float(next(it))
            except StopIteration:
                raise ValueError("--timeout requires a number")
            except ValueError as exc:
                raise ValueError(f"Invalid --timeout: {exc}")
            continue
        parts.append(token)

    message = " ".join(parts).strip()
    if timeout is None:
        try:
            timeout = float(os.environ.get("CCB_SYNC_TIMEOUT", "3600.0"))
        except Exception:
            timeout = 3600.0
    return output, timeout, message, quiet


def main(argv: list[str]) -> int:
    try:
        from cli_output import EXIT_ERROR, EXIT_NO_REPLY, EXIT_OK, atomic_write_text
        from codex_comm import CodexCommunicator

        output_path, timeout, message, quiet = _parse_args(argv)
        if not message and not sys.stdin.isatty():
            message = sys.stdin.read().strip()
        if not message:
            _usage()
            return EXIT_ERROR

        # Strict mode: require run_in_background=true in Claude Code
        if os.environ.get("CLAUDECODE") == "1" and not _check_background_mode():
            print("[ERROR] cask MUST be called with run_in_background=true", file=sys.stderr)
            print("Correct usage: Bash(cask \"...\", run_in_background=true)", file=sys.stderr)
            return EXIT_ERROR

        comm = CodexCommunicator(lazy_init=True)

        healthy, status = comm._check_session_health_impl(probe_terminal=False)
        if not healthy:
            raise RuntimeError(f"[ERROR] Session error: {status}")

        # Reset log state to ignore any messages before request dispatch
        comm.log_reader.capture_state()

        # Check if supervisor mode is enabled via roles config
        executor = _get_executor_from_roles()
        if executor == "codex+opencode":
            message = SUPERVISOR_PROMPT + message

        request_id = uuid.uuid4().hex
        start_marker, end_marker = _build_markers(request_id)

        _, state = comm._send_message(_with_completion_marker_request(message, start_marker, end_marker))
        reply, exit_code = _wait_for_complete_reply(comm.log_reader, state, timeout, quiet, start_marker, end_marker)
        if reply is None:
            if not quiet:
                print(f"[TIMEOUT] Timeout after {int(timeout)}s", file=sys.stderr)
            return exit_code

        if output_path:
            pending_path = Path(str(output_path) + ".pending")
            atomic_write_text(pending_path, reply + "\n")
            pending_path.replace(output_path)
            return exit_code

        sys.stdout.write(reply)
        if not reply.endswith("\n"):
            sys.stdout.write("\n")
        return exit_code
    except KeyboardInterrupt:
        return 130
    except Exception as exc:
        print(exc, file=sys.stderr)
        return 1


if __name__ == "__main__":
    raise SystemExit(main(sys.argv))
